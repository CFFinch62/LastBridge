/*
 * Settings persistence module for LAST - Linux Advanced Serial Transceiver
 * Handles loading and saving of application settings
 */

#include "settings.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>
#include <pwd.h>

char* get_config_file_path(void) {
    const char *home = getenv("HOME");
    if (!home) {
        struct passwd *pw = getpwuid(getuid());
        home = pw->pw_dir;
    }
    
    char *config_dir = malloc(strlen(home) + 20);
    sprintf(config_dir, "%s/.config", home);
    
    // Create .config directory if it doesn't exist
    mkdir(config_dir, 0755);
    
    char *config_path = malloc(strlen(home) + 40);
    sprintf(config_path, "%s/.config/last.conf", home);
    
    free(config_dir);
    return config_path;
}

void load_settings(SerialTerminal *terminal) {
    char *config_path = get_config_file_path();
    FILE *file = fopen(config_path, "r");
    
    if (!file) {
        free(config_path);
        return; // Use defaults if no config file
    }
    
    char line[512];
    char key[256], value[256];
    
    while (fgets(line, sizeof(line), file)) {
        // Skip comments, empty lines, and section headers
        if (line[0] == '#' || line[0] == '\n' || line[0] == '\r' || line[0] == '[') continue;

        if (sscanf(line, "%255[^=]=%255[^\n\r]", key, value) == 2) {
            // Appearance settings
            if (strcmp(key, "theme") == 0) {
                if (terminal->theme_preference) free(terminal->theme_preference);
                terminal->theme_preference = strdup(value);
            } else if (strcmp(key, "font_family") == 0) {
                if (terminal->font_family) free(terminal->font_family);
                terminal->font_family = strdup(value);
            } else if (strcmp(key, "font_size") == 0) {
                terminal->font_size = atoi(value);
            } else if (strcmp(key, "bg_color") == 0) {
                if (terminal->bg_color) free(terminal->bg_color);
                terminal->bg_color = strdup(value);
            } else if (strcmp(key, "text_color") == 0) {
                if (terminal->text_color) free(terminal->text_color);
                terminal->text_color = strdup(value);
            }
            // Display options
            else if (strcmp(key, "hex_display") == 0) {
                terminal->hex_display = (strcmp(value, "true") == 0);
            } else if (strcmp(key, "show_timestamps") == 0) {
                terminal->show_timestamps = (strcmp(value, "true") == 0);
            } else if (strcmp(key, "autoscroll") == 0) {
                terminal->autoscroll = (strcmp(value, "true") == 0);
            } else if (strcmp(key, "local_echo") == 0) {
                terminal->local_echo = (strcmp(value, "true") == 0);
            } else if (strcmp(key, "line_ending") == 0) {
                if (terminal->line_ending) free(terminal->line_ending);
                terminal->line_ending = strdup(value);
            }
            // Connection settings
            else if (strcmp(key, "port") == 0) {
                if (terminal->saved_port) free(terminal->saved_port);
                terminal->saved_port = strdup(value);
            } else if (strcmp(key, "baudrate") == 0) {
                if (terminal->saved_baudrate) free(terminal->saved_baudrate);
                terminal->saved_baudrate = strdup(value);
            } else if (strcmp(key, "databits") == 0) {
                if (terminal->saved_databits) free(terminal->saved_databits);
                terminal->saved_databits = strdup(value);
            } else if (strcmp(key, "parity") == 0) {
                if (terminal->saved_parity) free(terminal->saved_parity);
                terminal->saved_parity = strdup(value);
            } else if (strcmp(key, "stopbits") == 0) {
                if (terminal->saved_stopbits) free(terminal->saved_stopbits);
                terminal->saved_stopbits = strdup(value);
            } else if (strcmp(key, "flowcontrol") == 0) {
                if (terminal->saved_flowcontrol) free(terminal->saved_flowcontrol);
                terminal->saved_flowcontrol = strdup(value);
            }
        }
    }

    fclose(file);
    free(config_path);
}

void save_settings(SerialTerminal *terminal) {
    char *config_path = get_config_file_path();
    FILE *file = fopen(config_path, "w");
    
    if (!file) {
        free(config_path);
        return;
    }
    
    fprintf(file, "# LAST Configuration File\n");
    fprintf(file, "# This file is automatically generated\n\n");
    
    // Appearance settings
    fprintf(file, "[Appearance]\n");
    fprintf(file, "theme=%s\n", terminal->theme_preference ? terminal->theme_preference : "system");
    fprintf(file, "font_family=%s\n", terminal->font_family ? terminal->font_family : "Monospace");
    fprintf(file, "font_size=%d\n", terminal->font_size);
    fprintf(file, "bg_color=%s\n", terminal->bg_color ? terminal->bg_color : "#000000");
    fprintf(file, "text_color=%s\n", terminal->text_color ? terminal->text_color : "#00FF00");
    fprintf(file, "\n");
    
    // Display options
    fprintf(file, "[Display]\n");
    fprintf(file, "hex_display=%s\n", terminal->hex_display ? "true" : "false");
    fprintf(file, "show_timestamps=%s\n", terminal->show_timestamps ? "true" : "false");
    fprintf(file, "autoscroll=%s\n", terminal->autoscroll ? "true" : "false");
    fprintf(file, "local_echo=%s\n", terminal->local_echo ? "true" : "false");
    fprintf(file, "line_ending=%s\n", terminal->line_ending ? terminal->line_ending : "\\r\\n");
    fprintf(file, "\n");

    // Connection settings (save current UI state)
    fprintf(file, "[Connection]\n");
    if (terminal->port_combo) {
        const char *port = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->port_combo));
        if (port) fprintf(file, "port=%s\n", port);
    }
    if (terminal->baudrate_combo) {
        const char *baudrate = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->baudrate_combo));
        if (baudrate) fprintf(file, "baudrate=%s\n", baudrate);
    }
    if (terminal->databits_combo) {
        const char *databits = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->databits_combo));
        if (databits) fprintf(file, "databits=%s\n", databits);
    }
    if (terminal->parity_combo) {
        const char *parity = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->parity_combo));
        if (parity) fprintf(file, "parity=%s\n", parity);
    }
    if (terminal->stopbits_combo) {
        const char *stopbits = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->stopbits_combo));
        if (stopbits) fprintf(file, "stopbits=%s\n", stopbits);
    }
    if (terminal->flowcontrol_combo) {
        const char *flowcontrol = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->flowcontrol_combo));
        if (flowcontrol) fprintf(file, "flowcontrol=%s\n", flowcontrol);
    }
    fprintf(file, "\n");

    fclose(file);
    free(config_path);
}

void apply_loaded_settings(SerialTerminal *terminal) {
    if (!terminal->window) return; // UI not created yet

    // Apply appearance settings
    if (terminal->theme_combo) {
        const char *theme = terminal->theme_preference;
        if (theme) {
            if (strcasecmp(theme, "System") == 0) {
                gtk_combo_box_set_active(GTK_COMBO_BOX(terminal->theme_combo), 0);
            } else if (strcasecmp(theme, "Light") == 0) {
                gtk_combo_box_set_active(GTK_COMBO_BOX(terminal->theme_combo), 1);
            } else if (strcasecmp(theme, "Dark") == 0) {
                gtk_combo_box_set_active(GTK_COMBO_BOX(terminal->theme_combo), 2);
            }
        }
    }

    // Apply font settings
    if (terminal->font_button && terminal->font_family) {
        char font_desc[256];
        snprintf(font_desc, sizeof(font_desc), "%s %d", terminal->font_family, terminal->font_size);
        gtk_font_chooser_set_font(GTK_FONT_CHOOSER(terminal->font_button), font_desc);
    }

    // Apply color settings
    if (terminal->bg_color_button && terminal->bg_color) {
        GdkRGBA color;
        if (gdk_rgba_parse(&color, terminal->bg_color)) {
            gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(terminal->bg_color_button), &color);
        }
    }

    if (terminal->text_color_button && terminal->text_color) {
        GdkRGBA color;
        if (gdk_rgba_parse(&color, terminal->text_color)) {
            gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(terminal->text_color_button), &color);
        }
    }

    // Apply display settings
    if (terminal->hex_display_check) {
        gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(terminal->hex_display_check), terminal->hex_display);
    }
    if (terminal->timestamp_check) {
        gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(terminal->timestamp_check), terminal->show_timestamps);
    }
    if (terminal->autoscroll_check) {
        gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(terminal->autoscroll_check), terminal->autoscroll);
    }
    if (terminal->local_echo_check) {
        gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(terminal->local_echo_check), terminal->local_echo);
    }

    // Apply line ending setting
    if (terminal->line_ending_combo && terminal->line_ending) {
        if (strcmp(terminal->line_ending, "") == 0) {
            gtk_combo_box_set_active(GTK_COMBO_BOX(terminal->line_ending_combo), 0); // None
        } else if (strcmp(terminal->line_ending, "\r") == 0) {
            gtk_combo_box_set_active(GTK_COMBO_BOX(terminal->line_ending_combo), 1); // CR
        } else if (strcmp(terminal->line_ending, "\n") == 0) {
            gtk_combo_box_set_active(GTK_COMBO_BOX(terminal->line_ending_combo), 2); // LF
        } else if (strcmp(terminal->line_ending, "\r\n") == 0) {
            gtk_combo_box_set_active(GTK_COMBO_BOX(terminal->line_ending_combo), 3); // CR+LF
        }
    }

    // Apply connection settings
    if (terminal->saved_baudrate && terminal->baudrate_combo) {
        // Find and set the saved baudrate
        int count = gtk_tree_model_iter_n_children(gtk_combo_box_get_model(GTK_COMBO_BOX(terminal->baudrate_combo)), NULL);
        for (int i = 0; i < count; i++) {
            gtk_combo_box_set_active(GTK_COMBO_BOX(terminal->baudrate_combo), i);
            const char *text = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->baudrate_combo));
            if (text && strcmp(text, terminal->saved_baudrate) == 0) {
                break;
            }
        }
    }
    if (terminal->saved_databits && terminal->databits_combo) {
        int count = gtk_tree_model_iter_n_children(gtk_combo_box_get_model(GTK_COMBO_BOX(terminal->databits_combo)), NULL);
        for (int i = 0; i < count; i++) {
            gtk_combo_box_set_active(GTK_COMBO_BOX(terminal->databits_combo), i);
            const char *text = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->databits_combo));
            if (text && strcmp(text, terminal->saved_databits) == 0) {
                break;
            }
        }
    }
    if (terminal->saved_parity && terminal->parity_combo) {
        int count = gtk_tree_model_iter_n_children(gtk_combo_box_get_model(GTK_COMBO_BOX(terminal->parity_combo)), NULL);
        for (int i = 0; i < count; i++) {
            gtk_combo_box_set_active(GTK_COMBO_BOX(terminal->parity_combo), i);
            const char *text = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->parity_combo));
            if (text && strcmp(text, terminal->saved_parity) == 0) {
                break;
            }
        }
    }
    if (terminal->saved_stopbits && terminal->stopbits_combo) {
        int count = gtk_tree_model_iter_n_children(gtk_combo_box_get_model(GTK_COMBO_BOX(terminal->stopbits_combo)), NULL);
        for (int i = 0; i < count; i++) {
            gtk_combo_box_set_active(GTK_COMBO_BOX(terminal->stopbits_combo), i);
            const char *text = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->stopbits_combo));
            if (text && strcmp(text, terminal->saved_stopbits) == 0) {
                break;
            }
        }
    }
    if (terminal->saved_flowcontrol && terminal->flowcontrol_combo) {
        int count = gtk_tree_model_iter_n_children(gtk_combo_box_get_model(GTK_COMBO_BOX(terminal->flowcontrol_combo)), NULL);
        for (int i = 0; i < count; i++) {
            gtk_combo_box_set_active(GTK_COMBO_BOX(terminal->flowcontrol_combo), i);
            const char *text = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->flowcontrol_combo));
            if (text && strcmp(text, terminal->saved_flowcontrol) == 0) {
                break;
            }
        }
    }
}

void update_settings_from_ui(SerialTerminal *terminal) {
    // Update appearance settings from UI
    if (terminal->theme_combo) {
        const char *theme = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->theme_combo));
        if (theme) {
            if (terminal->theme_preference) free(terminal->theme_preference);
            terminal->theme_preference = strdup(theme);
        }
    }

    if (terminal->font_button) {
        const char *font_desc_str = gtk_font_chooser_get_font(GTK_FONT_CHOOSER(terminal->font_button));
        if (font_desc_str) {
            PangoFontDescription *font_desc = pango_font_description_from_string(font_desc_str);
            const char *family = pango_font_description_get_family(font_desc);
            int size = pango_font_description_get_size(font_desc) / PANGO_SCALE;

            if (terminal->font_family) free(terminal->font_family);
            terminal->font_family = strdup(family ? family : "Monospace");
            terminal->font_size = size > 0 ? size : 10;

            pango_font_description_free(font_desc);
        }
    }

    if (terminal->bg_color_button) {
        GdkRGBA color;
        gtk_color_chooser_get_rgba(GTK_COLOR_CHOOSER(terminal->bg_color_button), &color);
        char color_str[16];
        snprintf(color_str, sizeof(color_str), "#%02x%02x%02x",
                (int)(color.red * 255), (int)(color.green * 255), (int)(color.blue * 255));
        if (terminal->bg_color) free(terminal->bg_color);
        terminal->bg_color = strdup(color_str);
    }

    if (terminal->text_color_button) {
        GdkRGBA color;
        gtk_color_chooser_get_rgba(GTK_COLOR_CHOOSER(terminal->text_color_button), &color);
        char color_str[16];
        snprintf(color_str, sizeof(color_str), "#%02x%02x%02x",
                (int)(color.red * 255), (int)(color.green * 255), (int)(color.blue * 255));
        if (terminal->text_color) free(terminal->text_color);
        terminal->text_color = strdup(color_str);
    }

    // Update display settings from UI
    if (terminal->hex_display_check) {
        terminal->hex_display = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(terminal->hex_display_check));
    }
    if (terminal->timestamp_check) {
        terminal->show_timestamps = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(terminal->timestamp_check));
    }
    if (terminal->autoscroll_check) {
        terminal->autoscroll = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(terminal->autoscroll_check));
    }
    if (terminal->local_echo_check) {
        terminal->local_echo = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(terminal->local_echo_check));
    }

    // Update line ending setting
    if (terminal->line_ending_combo) {
        int active = gtk_combo_box_get_active(GTK_COMBO_BOX(terminal->line_ending_combo));
        if (terminal->line_ending) free(terminal->line_ending);
        switch (active) {
            case 0: terminal->line_ending = strdup(""); break;      // None
            case 1: terminal->line_ending = strdup("\r"); break;   // CR
            case 2: terminal->line_ending = strdup("\n"); break;   // LF
            case 3: terminal->line_ending = strdup("\r\n"); break; // CR+LF
            default: terminal->line_ending = strdup("\r\n"); break;
        }
    }

    // Update connection settings from UI
    if (terminal->port_combo) {
        const char *port = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->port_combo));
        if (port) {
            if (terminal->saved_port) free(terminal->saved_port);
            terminal->saved_port = strdup(port);
        }
    }
    if (terminal->baudrate_combo) {
        const char *baudrate = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->baudrate_combo));
        if (baudrate) {
            if (terminal->saved_baudrate) free(terminal->saved_baudrate);
            terminal->saved_baudrate = strdup(baudrate);
        }
    }
    if (terminal->databits_combo) {
        const char *databits = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->databits_combo));
        if (databits) {
            if (terminal->saved_databits) free(terminal->saved_databits);
            terminal->saved_databits = strdup(databits);
        }
    }
    if (terminal->parity_combo) {
        const char *parity = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->parity_combo));
        if (parity) {
            if (terminal->saved_parity) free(terminal->saved_parity);
            terminal->saved_parity = strdup(parity);
        }
    }
    if (terminal->stopbits_combo) {
        const char *stopbits = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->stopbits_combo));
        if (stopbits) {
            if (terminal->saved_stopbits) free(terminal->saved_stopbits);
            terminal->saved_stopbits = strdup(stopbits);
        }
    }
    if (terminal->flowcontrol_combo) {
        const char *flowcontrol = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->flowcontrol_combo));
        if (flowcontrol) {
            if (terminal->saved_flowcontrol) free(terminal->saved_flowcontrol);
            terminal->saved_flowcontrol = strdup(flowcontrol);
        }
    }
}
