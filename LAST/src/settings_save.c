/*
 * Settings saving module for LAST - Linux Advanced Serial Transceiver
 * Handles saving settings to file and updating from UI
 */

#include "settings.h"
#include "ui.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void save_settings(SerialTerminal *terminal) {
    char *config_path = get_config_file_path();
    FILE *file = fopen(config_path, "w");
    
    if (!file) {
        free(config_path);
        return;
    }
    
    fprintf(file, "# LAST Configuration File\n");
    fprintf(file, "# This file is automatically generated\n\n");
    
    // Appearance settings
    fprintf(file, "[Appearance]\n");
    fprintf(file, "theme=%s\n", terminal->theme_preference ? terminal->theme_preference : "system");
    fprintf(file, "font_family=%s\n", terminal->font_family ? terminal->font_family : "Monospace");
    fprintf(file, "font_size=%d\n", terminal->font_size);
    fprintf(file, "bg_color=%s\n", terminal->bg_color ? terminal->bg_color : "#000000");
    fprintf(file, "text_color=%s\n", terminal->text_color ? terminal->text_color : "#00FF00");
    fprintf(file, "\n");
    
    // Display options
    fprintf(file, "[Display]\n");
    fprintf(file, "hex_display=%s\n", terminal->hex_display ? "true" : "false");
    fprintf(file, "hex_bytes_per_line=%d\n", terminal->hex_bytes_per_line);
    fprintf(file, "show_timestamps=%s\n", terminal->show_timestamps ? "true" : "false");
    fprintf(file, "autoscroll=%s\n", terminal->autoscroll ? "true" : "false");
    fprintf(file, "local_echo=%s\n", terminal->local_echo ? "true" : "false");
    fprintf(file, "line_ending=%s\n", terminal->line_ending ? terminal->line_ending : "\\r\\n");
    fprintf(file, "\n");

    // Connection settings (save current UI state)
    fprintf(file, "[Connection]\n");
    if (terminal->connection_type_combo) {
        const char *connection_type = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->connection_type_combo));
        if (connection_type) fprintf(file, "connection_type=%s\n", connection_type);
    }
    if (terminal->network_host_entry) {
        const char *host = gtk_entry_get_text(GTK_ENTRY(terminal->network_host_entry));
        if (host) fprintf(file, "network_host=%s\n", host);
    }
    if (terminal->network_port_entry) {
        const char *port = gtk_entry_get_text(GTK_ENTRY(terminal->network_port_entry));
        if (port) fprintf(file, "network_port=%s\n", port);
    }
    if (terminal->port_combo) {
        const char *port = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->port_combo));
        if (port) fprintf(file, "port=%s\n", port);
    }
    if (terminal->baudrate_combo) {
        const char *baudrate = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->baudrate_combo));
        if (baudrate) fprintf(file, "baudrate=%s\n", baudrate);
    }
    if (terminal->databits_combo) {
        const char *databits = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->databits_combo));
        if (databits) fprintf(file, "databits=%s\n", databits);
    }
    if (terminal->parity_combo) {
        const char *parity = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->parity_combo));
        if (parity) fprintf(file, "parity=%s\n", parity);
    }
    if (terminal->stopbits_combo) {
        const char *stopbits = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->stopbits_combo));
        if (stopbits) fprintf(file, "stopbits=%s\n", stopbits);
    }
    if (terminal->flowcontrol_combo) {
        const char *flowcontrol = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->flowcontrol_combo));
        if (flowcontrol) fprintf(file, "flowcontrol=%s\n", flowcontrol);
    }
    fprintf(file, "\n");

    // File operations settings
    fprintf(file, "[FileOperations]\n");
    if (terminal->send_file_lines_check) {
        gboolean lines_mode = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(terminal->send_file_lines_check));
        fprintf(file, "line_by_line_mode=%s\n", lines_mode ? "true" : "false");
    }
    fprintf(file, "line_by_line_delay_ms=%d\n", terminal->line_by_line_delay_ms);
    fprintf(file, "\n");

    // Macro settings
    fprintf(file, "[Macros]\n");
    fprintf(file, "macro_panel_visible=%s\n", terminal->macro_panel_visible ? "true" : "false");
    for (int i = 0; i < MAX_MACRO_BUTTONS; i++) {
        fprintf(file, "macro_%d_label=%s\n", i, terminal->macro_labels[i]);
        fprintf(file, "macro_%d_command=%s\n", i, terminal->macro_commands[i]);
    }
    fprintf(file, "\n");

    fclose(file);
    free(config_path);
}

void update_settings_from_ui(SerialTerminal *terminal) {
    // Update appearance settings from UI
    if (terminal->theme_combo) {
        const char *theme = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->theme_combo));
        if (theme) {
            if (terminal->theme_preference) free(terminal->theme_preference);
            terminal->theme_preference = strdup(theme);
        }
    }

    if (terminal->font_button) {
        const char *font_desc_str = gtk_font_chooser_get_font(GTK_FONT_CHOOSER(terminal->font_button));
        if (font_desc_str) {
            PangoFontDescription *font_desc = pango_font_description_from_string(font_desc_str);
            const char *family = pango_font_description_get_family(font_desc);
            int size = pango_font_description_get_size(font_desc) / PANGO_SCALE;

            if (terminal->font_family) free(terminal->font_family);
            terminal->font_family = strdup(family ? family : "Monospace");
            terminal->font_size = size > 0 ? size : 10;

            pango_font_description_free(font_desc);
        }
    }

    if (terminal->bg_color_button) {
        GdkRGBA color;
        gtk_color_chooser_get_rgba(GTK_COLOR_CHOOSER(terminal->bg_color_button), &color);
        char color_str[16];
        snprintf(color_str, sizeof(color_str), "#%02x%02x%02x",
                (int)(color.red * 255), (int)(color.green * 255), (int)(color.blue * 255));
        if (terminal->bg_color) free(terminal->bg_color);
        terminal->bg_color = strdup(color_str);
    }

    if (terminal->text_color_button) {
        GdkRGBA color;
        gtk_color_chooser_get_rgba(GTK_COLOR_CHOOSER(terminal->text_color_button), &color);
        char color_str[16];
        snprintf(color_str, sizeof(color_str), "#%02x%02x%02x",
                (int)(color.red * 255), (int)(color.green * 255), (int)(color.blue * 255));
        if (terminal->text_color) free(terminal->text_color);
        terminal->text_color = strdup(color_str);
    }

    // Update display settings from UI
    if (terminal->hex_display_check) {
        terminal->hex_display = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(terminal->hex_display_check));
    }
    if (terminal->hex_bytes_per_line_combo) {
        const char *selection = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->hex_bytes_per_line_combo));
        if (selection) {
            if (strcmp(selection, "Auto (CR+LF)") == 0) {
                terminal->hex_bytes_per_line = 0;
            } else {
                terminal->hex_bytes_per_line = atoi(selection);
            }
        }
    }
    if (terminal->timestamp_check) {
        terminal->show_timestamps = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(terminal->timestamp_check));
    }
    if (terminal->autoscroll_check) {
        terminal->autoscroll = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(terminal->autoscroll_check));
    }
    if (terminal->local_echo_check) {
        terminal->local_echo = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(terminal->local_echo_check));
    }

    // Update line ending setting
    if (terminal->line_ending_combo) {
        int active = gtk_combo_box_get_active(GTK_COMBO_BOX(terminal->line_ending_combo));
        if (terminal->line_ending) free(terminal->line_ending);
        switch (active) {
            case 0: terminal->line_ending = strdup(""); break;      // None
            case 1: terminal->line_ending = strdup("\r"); break;   // CR
            case 2: terminal->line_ending = strdup("\n"); break;   // LF
            case 3: terminal->line_ending = strdup("\r\n"); break; // CR+LF
            default: terminal->line_ending = strdup("\r\n"); break;
        }
    }

    // Update connection type from UI
    if (terminal->connection_type_combo) {
        const char *connection_type = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->connection_type_combo));
        if (connection_type) {
            if (terminal->saved_connection_type) free(terminal->saved_connection_type);
            terminal->saved_connection_type = strdup(connection_type);
        }
    }

    // Update network settings from UI
    if (terminal->network_host_entry) {
        const char *host = gtk_entry_get_text(GTK_ENTRY(terminal->network_host_entry));
        if (host) {
            if (terminal->saved_network_host) free(terminal->saved_network_host);
            terminal->saved_network_host = strdup(host);
        }
    }
    if (terminal->network_port_entry) {
        const char *port = gtk_entry_get_text(GTK_ENTRY(terminal->network_port_entry));
        if (port) {
            if (terminal->saved_network_port) free(terminal->saved_network_port);
            terminal->saved_network_port = strdup(port);
        }
    }

    // Update connection settings from UI
    if (terminal->port_combo) {
        const char *port = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->port_combo));
        if (port) {
            if (terminal->saved_port) free(terminal->saved_port);
            terminal->saved_port = strdup(port);
        }
    }
    if (terminal->baudrate_combo) {
        const char *baudrate = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->baudrate_combo));
        if (baudrate) {
            if (terminal->saved_baudrate) free(terminal->saved_baudrate);
            terminal->saved_baudrate = strdup(baudrate);
        }
    }
    if (terminal->databits_combo) {
        const char *databits = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->databits_combo));
        if (databits) {
            if (terminal->saved_databits) free(terminal->saved_databits);
            terminal->saved_databits = strdup(databits);
        }
    }
    if (terminal->parity_combo) {
        const char *parity = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->parity_combo));
        if (parity) {
            if (terminal->saved_parity) free(terminal->saved_parity);
            terminal->saved_parity = strdup(parity);
        }
    }
    if (terminal->stopbits_combo) {
        const char *stopbits = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->stopbits_combo));
        if (stopbits) {
            if (terminal->saved_stopbits) free(terminal->saved_stopbits);
            terminal->saved_stopbits = strdup(stopbits);
        }
    }
    if (terminal->flowcontrol_combo) {
        const char *flowcontrol = gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(terminal->flowcontrol_combo));
        if (flowcontrol) {
            if (terminal->saved_flowcontrol) free(terminal->saved_flowcontrol);
            terminal->saved_flowcontrol = strdup(flowcontrol);
        }
    }

    // Apply file operations settings
    if (terminal->send_file_lines_check) {
        gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(terminal->send_file_lines_check), terminal->line_by_line_mode);
        // Update the interval dropdown based on the loaded setting
        update_interval_dropdown_based_on_mode(terminal);
    }

    // Apply macro button labels and panel visibility
    for (int i = 0; i < MAX_MACRO_BUTTONS; i++) {
        if (terminal->macro_buttons[i]) {
            gtk_button_set_label(GTK_BUTTON(terminal->macro_buttons[i]), terminal->macro_labels[i]);
        }
    }

    // Apply macro panel visibility
    if (terminal->macro_panel) {
        if (terminal->macro_panel_visible) {
            gtk_widget_show(terminal->macro_panel);
        } else {
            gtk_widget_hide(terminal->macro_panel);
        }
    }
}

